#!/usr/bin/perl 
# Take each line of output file and find Hilbert basis


# Makes sure that an input file is specifed
if (@ARGV < 1) { 
	die "No file specified\n";		# error message
} else {
	print "Processing @ARGV[0]\n";	
}

# Opens file 
if (! open INPUT, "@ARGV[0]") {
	die "Trouble opening file @ARGV[0]\n";		# error message
}

# Iterates all the lines of the input file
while (<INPUT>) {
	chomp;
	system "touch temp/tempfile.in";
	if (! open OUTPUT_FILE, ">", "temp/tempfile.in") {
		close INPUT;
		die "Trouble opening tempfile\n";		# error message
	}
	
	# Take in line and bulid 4x4 matrix file in Normaliz format
	printf OUTPUT_FILE "4\n4\n1 0 0 0\n0 1 0 0\n0 0 1 0\n%s\nintegral_closure\n", join(" ", split(/,/, $_));
	close OUTPUT_FILE;
	
	
	# Find Hilbert basis
	# Take the temp file, put in Normaliz and get Hilbert basis (.gen -f)
	system "/Applications/Normaliz/norm64 -f temp/tempfile.in";
	

	# Input Hilbert basis
	# Opens file TEMPFILE.GEN
	if (! open TEMPFILEGEN, "temp/tempfile.gen") {
		close INPUT;
		die "Trouble opening file temp/tempfile.gen\n";		# error message
	}


	# Slurp the hibert basis matrix into an array
	@hilbert_data = <TEMPFILEGEN>;
	close TEMPFILEGEN;

	# Take off the first two elements of the array (unnecessary row and column data)
	if(scalar(@hilbert_data) > 2) {
		@hilbert_data = @hilbert_data[2..$#hilbert_data];
	}

	# Find unimodular simplicies
	
	
	# Create temp file for Sage commands
	# Using a temp file makes Sage run faster
	$SAGE_TEMPFILE = "temp.sage";
	system "rm $SAGE_TEMPFILE";
	system "touch $SAGE_TEMPFILE";
	if (! open SAGE_OUTPUT_FILE, ">", "$SAGE_TEMPFILE") {
		close INPUT;
		die "Trouble opening sage tempfile\n";		# error message
	}
	
	
	# Array of every 4x4 matricies
	@matrices;
	@hilbertLineNumbers;

	$count = 0;
	# Take all 4x4 submatricies of the .gen matrix 
	# Use Sage to find determinant
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {
		for ($ij = $ix+1; $ij < scalar(@hilbert_data); $ij++) {
			for ($iy = $ij+1; $iy < scalar(@hilbert_data); $iy++) {
				for ($iz = $iy+1; $iz < scalar(@hilbert_data); $iz++) {
					
					# Builds 4x4 matrix from Hilbert basis
					@subarray = (split(/\s+/,@hilbert_data[$ix]), split(/\s+/,@hilbert_data[$ij]), split(/\s+/,@hilbert_data[$iy]), split(/\s+/,@hilbert_data[$iz]));
					
					# Puts all submatricies in array
					@matrices[$count] = join(',', @subarray);
					push(@hilbertLineNumbers, "$ix,$ij,$iy,$iz");
					$count++;

					# Builds commad
					$command = sprintf("M = MatrixSpace(QQ,4,4); A = M([%s]); print det(A);\n", join(',', @subarray));

					# Puts commands into temp file
					print SAGE_OUTPUT_FILE $command;
				}
			}
		}
	}
	
	close SAGE_OUTPUT_FILE;

	$now = time;
	
	# Store determinants in temp file, line numbers corresponds to line numbers in @matricies array
	$DETERMINANTS_FILE = 'sage_determinants.txt';

	# Use Sage to find determinants
	$command = "/Applications/sage/sage $SAGE_TEMPFILE > $DETERMINANTS_FILE";
	system $command;
	$later = time;
	printf "Took %d seconds to run $count matrices through sage\n\n", ($later-$now), $count;
	
	
	# Capture determiant value
	# Read in determinants form temp file
	if (! open DETERMINANTS_FILE, $DETERMINANTS_FILE) {
		close INPUT;
		die "Trouble opening file $DETERMINANTS_FILE\n";		# error message
	}


	# Slurp the determinatns into an array
	@determinants = <DETERMINANTS_FILE>;
	
	close DETERMINANTS_FILE;
	
	# Find unimodular simplicies and store in @unimodular_array
	@unimodular_array;
	@unimodular_list;	
	$count = 0;
	for($ix = 0; $ix < scalar(@determinants); $ix++) {
		$det = int(@determinants[$ix]);

		# If det= = 1,-1 save simplex
		if ($det == -1 || $det == 1) {
			push(@unimodular_array, @matrices[$ix]);
			
			# Keep track of Hilbert basis line numbers
			push(@unimodular_list, @hilbertLineNumbers[$ix]);
		}
	}
	
	printf "Unimodular List is %d long\n", scalar(@unimodular_list);
	
	
	# Generate a generic point

	@random_array;
	
	# Generate random rational numbers between 0 and 10,000
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {		
		$r = rand(10_000);
		@random_array[$ix] = $r;
	}


	# Generate generic_pt
	@generic_pt;
	for ($ix = 0; $ix < 4; $ix++) {		
		$temp = 0;		
		for ($iy = 0; $iy < scalar(@hilbert_data); $iy++) {	
			$random = @random_array[$iy];
			@hilbert = split(/\s+/, @hilbert_data[$iy]);
			$temp += ($random * @hilbert[$ix]);
		}			
		@generic_pt[$ix] = $temp;
	}
	
	# printf "Generic point is %s\n", join(', ', @generic_pt);


	# Find simplicies in which the generic_pt lives	
	
	# Create temp file for Sage commands
	$GENERIC_TEMPFILE = "generic.sage";
	system "rm $GENERIC_TEMPFILE";
	system "touch $GENERIC_TEMPFILE";
	if (! open GENERIC_OUTPUT_FILE, ">", "$GENERIC_TEMPFILE") {
		close INPUT;
		die "Trouble opening generic point tempfile\n";		# error message
	}
	
	
	@unimodular_transpose;
	$string;
	@string;
	@transpose;
	@unimodular_transpose;
	# Find the tranpose of each 4x4 unimodular matrix
	for ($ix = 0; $ix < scalar(@unimodular_array); $ix++) {
		$count = 0;
		$string = @unimodular_array[$ix];
		@string = split(/,/, $string);	

		for ($iy = 0; $iy < 16; $iy += 4) {
			@transpose[$count] = @string[$iy];
			$count++;
		}
		for ($ij = 1; $ij < 16; $ij += 4) {
			@transpose[$count] = @string[$ij];
			$count++;
		}
		for ($ik = 2; $ik < 16; $ik += 4) {
			@transpose[$count] = @string[$ik];
			$count++;
		}
		for ($iz = 3; $iz < 16; $iz += 4) {
			@transpose[$count] = @string[$iz];
			$count++;
		}
				
		# Puts all submatricies in array
		@unimodular_transpose[$ix] = join(',',@transpose);		
	}
	
	# Take each unimodular simplex and ask Sage to solve A_i [x_1,x_2,x_3,x_4] = generic_pt
	for ($ix = 0; $ix < scalar(@unimodular_transpose); $ix++) {
		# Build Sage commands
		$command = sprintf "M44 = MatrixSpace(QQ,4,4); A = M44([%s]); V4 = VectorSpace(QQ,4); b = V4([%s]); print octave.solve_linear_system(A,b); \n", @unimodular_transpose[$ix], join(',', @generic_pt);
		print GENERIC_OUTPUT_FILE $command;
	}

	close GENERIC_OUTPUT_FILE;
	
	# Use Sage to find solution
	$SOLUTIONS_FILE = "generic.sage.out";
	system "/Applications/sage/sage $GENERIC_TEMPFILE > $SOLUTIONS_FILE";
	
	
	# Capture solutions
	# Read in solutions form temp file
	if (! open SOLUTIONS_FILE, $SOLUTIONS_FILE) {
		close INPUT;
		die "Trouble opening file $SOLUTIONS_FILE\n";		# error message
	}


	# Slurp the solutions into an array
	@solutions_array = <SOLUTIONS_FILE>;
	close SOLUTIONS_FILE;

	# If matrix of has a positive solution, then generic_pt lives inside simplex
	# First equation is sum x = 1 for those simplicies it lives inside
	
	@first_eq_array;
	@solution;
	
	for($ix = 0; $ix < scalar(@solutions_array); $ix++) {
		# Clean and split the solution (4 numbers)
		$string = @solutions_array[$ix];		
		chomp($string);
		@solution = split(/,/, substr($string, 1, length($string)-2));
		
		# iterate the solution array
		$all_positive = 1;
		for($ij = 0; $ij < scalar(@solution); $ij++) {			
			if(@solution[$ij] <= 0) {
				$all_positive = 0;
			}
		}
		
		push(@first_eq_array, $all_positive);
				
	}
	
#	printf "Solutions array is %d elements long\n", scalar(@solutions_array);
#	printf "Equations array is %d elements long\n", scalar(@first_eq_array);

	# Last entry in first equation is 1
	push(@first_eq_array, 1);

	printf "First equation %s\n", join(', ', @first_eq_array);

	# Finds the interior facets of the simplicies
		

	# For each simpliex gererate facets
	# define new 4x4 matrix F = [ x_i line 2 line 3 line 4] 
	# Find all simplices that contain that facet


	@facets;
	# Find all possible facets
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {
		for ($ij = $ix+1; $ij < scalar(@hilbert_data); $ij++) {
			for ($iy = $ij+1; $iy < scalar(@hilbert_data); $iy++) {
				
				push(@facets, "$ix,$ij,$iy");
			}
		}
	}

	@currentFacet;
	@currentUnimodular;
	
	# For each facet check if it is in a unimodular simplex
	# use line numbers	
	
	for ($ix = 0; $ix < scalar(@facets); $ix++) {
		@currentFacet = split(/,/, @facets[$ix]);
		
		for ($iy = 0; $iy < scalar(@unimodular_list); $iy++) {
			@currentUnimodular = split(/,/, @unimodular_list[$iy]);
			
			$matchCount = 0;
			for($ij = 0; $ij < scalar(@currentFacet); $ij++) {
				for($ik = 0; $ik < scalar(@currentUnimodular); $ik++) {
					if(@currentFacet[$ij] eq @currentUnimodular[$ik]) {
						$matchCount++;	
					}
				}
			}
			
			if($matchCount == 3) {
				print "@currentUnimodular contains @currentFacet\n";				
				# if the facet is in the unimodular simplex then
				# check if it is interior
			}
			# if no interior trash
			# if interior then 
			# check sign
			# if positive save 1
			# if negative save -1
			
			# if the facet is not then
			# save 0 in equation array							

		}
		
		
	}
	exit;
	# at the end of each equation array save 0

	# save first equation array and all other in one file of the form
	# number of equations = i
	# number of variables
	# equations
	# last line "linearity i 1, 2, 3, ..."


	
	


	@int_facet_array;
	
	# Create temp file for Latte equations
	$LATTE_TEMPFILE = "temp.latte";
	system "rm $LATTE_TEMPFILE";
	system "touch $LATTE_TEMPFILE";
	if (! open LATTE_INPUT_FILE, ">", "$LATTE_TEMPFILE") {
		die "Trouble opening latte tempfile\n";		# error message
	}
	
	printf LATTTE_INPUT_FILE "scalar(@int_facet_array)\nscalar(@unimodular_array)\n";
	

	

	
	
	
	# use Latte for yes or no answer
	# Is there a lattice point?  ./count int temp.latte

	#system "/Applications/latte ./count int temp.latte";
	#chomp($answer = 'answer')
	# if no then keep hilbert_basis tempfile
	#if (!$answer) 
	
	
	
	


}

close INPUT;






