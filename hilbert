#!/usr/bin/perl 
# Take each line of output file and find Hilbert basis

# Makes sure that an input file is specifed
if (@ARGV < 1) { 
	die "No file specified\n";		# error message
} else {
	print "Processing @ARGV[0]\n";	
}

# Opens file 
if (! open INPUT, "@ARGV[0]") {
	die "Trouble opening file @ARGV[0]\n";		# error message
}

# Iterates all the lines of the input file
while (<INPUT>) {
	chomp;
	system "touch temp/tempfile.in";
	if (! open OUTPUT_FILE, ">", "temp/tempfile.in") {
		die "Trouble opening tempfile\n";		# error message
		close INPUT;
	}
	
	# Take in line and bulid 4x4 matrix file in Normaliz format
	printf OUTPUT_FILE "4\n4\n1 0 0 0\n0 1 0 0\n0 0 1 0\n%s\nintegral_closure\n", join(" ", split(/,/, $_));
	close OUTPUT_FILE;
	
	
	# Find Hilbert basis
	# Take the temp file, put in Normaliz and get Hilbert basis (.gen -f)
	system "/Applications/Normaliz/norm64 -f temp/tempfile.in";
	

	# Input Hilbert basis
	# Opens file TEMPFILE.GEN
	if (! open TEMPFILEGEN, "temp/tempfile.gen") {
		die "Trouble opening file temp/tempfile.gen\n";		# error message
	}


	# Slurp the hibert basis matrix into an array
	@hilbert_data = <TEMPFILEGEN>;

	
	# Take off the first two elements of the array (unnecessary row and column data)
	if(scalar(@hilbert_data) > 2) {
		@hilbert_data = @hilbert_data[2..$#hilbert_data];
	}
	


	# Find unimodular simplicies
	
	
	# Create temp file for Sage commands
	# Using a temp file makes Sage run faster
	$SAGE_TEMPFILE = "temp.sage";
	system "rm $SAGE_TEMPFILE";
	system "touch $SAGE_TEMPFILE";
	if (! open SAGE_OUTPUT_FILE, ">", "$SAGE_TEMPFILE") {
		die "Trouble opening sage tempfile\n";		# error message
	}
	
	
	# Array of every 4x4 matricies
	@matrices;
	@list;

	$count = 0;
	# Take all 4x4 submatricies of the .gen matrix 
	# Use Sage to find determinant
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {
		for ($ij = $ix+1; $ij < scalar(@hilbert_data); $ij++) {
			for ($iy = $ij+1; $iy < scalar(@hilbert_data); $iy++) {
				for ($iz = $iy+1; $iz < scalar(@hilbert_data); $iz++) {
					
					# Builds 4x4 matrix from Hilbert basis
					@subarray = (split(/\s+/,@hilbert_data[$ix]), split(/\s+/,@hilbert_data[$ij]), split(/\s+/,@hilbert_data[$iy]), split(/\s+/,@hilbert_data[$iz]));
					
					# Puts all submatricies in array
					@matrices[$count] = join(',', @subarray);
					@list = "$ix, $ij, $iy, $iz\n";
					$count++;

					# Builds commad
					$command = sprintf("M = MatrixSpace(QQ,4,4); A = M([%s]); print det(A);\n", join(',', @subarray));

					# Puts commands into temp file
					print SAGE_OUTPUT_FILE $command;
				}
			}
		}
	}
	
	close SAGE_OUTPUT_FILE;

	$now = time;
	
	# Store determinants in temp file, line numbers corresponds to line numbers in @matricies array
	$DETERMINANTS_FILE = 'sage_determinants.txt';

	# Use Sage to find determinants
	$command = "/Applications/sage/sage $SAGE_TEMPFILE > $DETERMINANTS_FILE";
	system $command;
	$later = time;
	printf "Took %d seconds to run $count matrices through sage\n\n", ($later-$now), $count;
	
	
	# Capture determiant value
	# Read in determinants form temp file
	if (! open DETERMINANTS_FILE, $DETERMINANTS_FILE) {
		die "Trouble opening file $DETERMINANTS_FILE\n";		# error message
	}


	# Slurp the determinatns into an array
	@determinants = <DETERMINANTS_FILE>;
	
	close DETERMINANTS_FILE;
	
	# Find unimodular simplicies and store in @unimodular_array
	@unimodular_array;
	@unimodular_list;	
	$count = 0;
	for($ix = 0; $ix < scalar(@determinants); $ix++) {
		$det = int(@determinants[$ix]);

		# If det= = 1,-1 save simplex
		if ($det == -1 || $det == 1) {
			@unimodular_array[$count] = @matrices[$ix];
			$count++;
			
			# Keep track of Hilbert basis line numbers
			@unimodular_list[$count] = @list[$ix];
		}
	}
	
	
	# Generate a generic point

	@random_array;
	
	# Generate random rational numbers between 0 and 10,000
	for ($iy = 0; $iy < scalar(@hilbert_data); $iy++) {		
		$r = rand(10_000);
		@random_array[$iy] = $r;
	}


	# Generate generic_pt
	@generic_pt;
	for ($ix = 0; $ix < 4; $ix++) {		
		$temp = 0;		
		for ($iy = 0; $iy < scalar(@hilbert_data); $iy++) {	
			$random = @random_array[$iy];
			@hilbert = split(/\s+/, @hilbert_data[$iy]);
			$temp += ($random * @hilbert[$ix]);
		}			
		@generic_pt[$ix] = $temp;
	}
	
	printf "Generic point is %s\n", join(', ', @generic_pt);


	# Find simplicies in which the generic_pt lives	
	
	# Create temp file for Sage commands
	$GENERIC_TEMPFILE = "generic.sage";
	system "rm $GENERIC_TEMPFILE";
	system "touch $GENERIC_TEMPFILE";
	if (! open GENERIC_OUTPUT_FILE, ">", "$GENERIC_TEMPFILE") {
		die "Trouble opening generic point tempfile\n";		# error message
	}
	
	
	@unimodular_transpose;
	$string;
	@string;
	@transpose;
	@unimodular_transpose;
	
	# Find the tranpose of each 4x4 unimodular matrix
	for ($ix = 0; $ix < scalar(@unimodular_array); $ix++) {
		$count = 0;
		$string = @unimodular_array[$ix];
		@string = split(/,/, $string);	

		for ($iy = 0; $iy < 16; $iy += 4) {
			@transpose[$count] = @string[$iy];
			$count++;
		}
		for ($ij = 1; $ij < 16; $ij += 4) {
			@transpose[$count] = @string[$ij];
			$count++;
		}
		for ($ik = 2; $ik < 16; $ik += 4) {
			@transpose[$count] = @string[$ik];
			$count++;
		}
		for ($iz = 3; $iz < 16; $iz += 4) {
			@transpose[$count] = @string[$iz];
			$count++;
		}
				
		# Puts all submatricies in array
		@unimodular_transpose[$ix] = @transpose;		
	}
	
	exit;

	
	# Take each unimodular simplex and ask Sage to solve A_i [x_1,x_2,x_3,x_4] = generic_pt
	for ($iy = 0; $iy < scalar(@unimodular_transpose); $iy++) {

		# Build Sage commands
		$command = sprintf "M44 = MatrixSpace(QQ,4,4); A = M44([%s]); V4 = VectorSpace(QQ,4); b = V4([%s]); print octave.solve_linear_system(A,b); \n", join(',', @unimodular_transpose[$iy]), join(',', @generic_pt);

		print GENERIC_OUTPUT_FILE $command;
	}

	close GENERIC_OUTPUT_FILE;
	
	# Use Sage to find solution
	$SOLUTIONS_FILE = "generic.sage.out";
	system "/Applications/sage/sage $GENERIC_TEMPFILE > $SOLUTIONS_FILE";
	
	
	# Capture solutions
	# Read in solutions form temp file
	if (! open SOLUTIONS_FILE, $SOLUTIONS_FILE) {
		die "Trouble opening file $SOLUTIONS_FILE\n";		# error message
	}


	# Slurp the solutions into an array
	@solutions_array = <SOLUTIONS_FILE>;


	# If matrix of has a positive solution, then generic_pt lives inside simplex
	# First equation is sum x = 1 for those simplicies it lives inside
	
	@first_eq_array;
	@solution;
	
	printf "solutions_array %s\n", join(', ', @solutions_array);
	
	$count = 0;
	$string;
	for($ix = 0; $ix < scalar(@solutions_array); $ix++) {
		$positive = 0;
		for ($iy = 0; $iy < 4; $iy++) {
			$string = @solutions_array[$ix];
			@solution = split(/,/, substr($string, 1, length($string)-2));	
			printf "@solution[$iy]\n";		
			$solution = @solution[$iy];
			
			if ($solution > 0) {
				$positive++;
			} 
		}
		
		# If solution > 0, then put 1 into first_eq_array
		if ($positive == 4) {
			@first_eq_array_[$ix] = 1;
			$count++;
		} else {		# If solution is not positive then put 0 in to first_eq_array
			@first_eq_array_[$ix] = 0;
		}
	}

	printf "The generic point lives in %d simplicies\n", $count;


	
	# Last entry in first equation is 1
	@first_eq_array[scalar(@solutions_array)] = 1;

	printf "First equation %s\n", join(', ', @first_eq_array);

exit;
	
	# Finds the interior facets of the simplicies
		

	# For each simpliex gererate facets
	# define new 4x4 matrix F = [ x_i line 2 line 3 line 4] 
	# Find all simplices that contain that facet


	@facets;
	@subfacet;
	# Find all possible facets
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {
		for ($ij = $ix+1; $ij < scalar(@hilbert_data); $ij++) {
			for ($iy = $ij+1; $iy < scalar(@hilbert_data); $iy++) {
				
				# build list of possible facets
				@subfacet = "$ix, $ij, $iy";
				
				# Puts all list in array
				@facets[$count] = @subfacet;
				$count++;
			}
		}
	}


	@tempfacet;
	@templist;
	
	# For each facet check if it is in a unimodular simplex
	# use line numbers
	
	for ($ix = 0; $ix < scalar(@facets); $ix++) {
		@tempfacet = split(/\s+/, @facets[$ix]);
		
		for ($iy = 0; $iy < scalar(@unimodular_list); $iy++) {
			@templist = split(/\s+/, @unimodular_list[$iy]);
			
			for ($ij = 0; $ij < scalar(@templist); $ij++) {
				
				# Check if facet is in the unimodular simplex by using line numbers
				
				# if the facet is in the unimodular simplex then
				# check if it is interior
				# if no interior trash
				# if interior then 
				# check sign
				# if positive save 1
				# if negative save -1
				
				# if the facet is not then
				# save 0 in equation array
				
			}

		}
		
		
	}
	
	# at the end of each equation array save 0

	# save first equation array and all other in one file of the form
	# number of equations = i
	# number of variables
	# equations
	# last line "linearity i 1, 2, 3, ..."


	
	


	@int_facet_array;
	
	# Create temp file for Latte equations
	$LATTE_TEMPFILE = "temp.latte";
	system "rm $LATTE_TEMPFILE";
	system "touch $LATTE_TEMPFILE";
	if (! open LATTE_INPUT_FILE, ">", "$LATTE_TEMPFILE") {
		die "Trouble opening latte tempfile\n";		# error message
	}
	
	printf LATTTE_INPUT_FILE "scalar(@int_facet_array)\nscalar(@unimodular_array)\n";
	

	

	
	
	
	# use Latte for yes or no answer
	# Is there a lattice point?  ./count int temp.latte

	#system "/Applications/latte ./count int temp.latte";
	#chomp($answer = 'answer')
	# if no then keep hilbert_basis tempfile
	#if (!$answer) 
	
	
	
	


}

close INPUT;







