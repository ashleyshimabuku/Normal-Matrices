#!/usr/bin/perl 


# Makes sure that an input file is specifed
if (@ARGV < 1) { 
	die "No file specified\n";		# error message
} else {
	print "Processing @ARGV[0]\n";	
}

# Opens file 
if (! open INPUT, "@ARGV[0]") {
	die "Trouble opening file @ARGV[0]\n";		# error message
}

# Iterates all the lines of the input file
# Take each line find Hilbert basis
while (<INPUT>) {
	chomp;
	system "touch temp/tempfile.in";
	if (! open OUTPUT_FILE, ">", "temp/tempfile.in") {
		close INPUT;
		die "Trouble opening tempfile\n";		# error message
	}
	
	# Take in line and bulid 4x4 matrix file in Normaliz format
	printf OUTPUT_FILE "4\n4\n1 0 0 0\n0 1 0 0\n0 0 1 0\n%s\nintegral_closure\n", join(" ", split(/,/, $_));
	close OUTPUT_FILE;
	
	# Find Hilbert basis
	# Take the temp file, put in Normaliz and get Hilbert basis (.gen -f)
	system "/Applications/Normaliz/norm64 -f temp/tempfile.in";

	# Input Hilbert basis
	# Opens file TEMPFILE.GEN
	if (! open TEMPFILEGEN, "temp/tempfile.gen") {
		close INPUT;
		die "Trouble opening file temp/tempfile.gen\n";		# error message
	}

	# Slurp the hibert basis matrix into an array
	@hilbert_data = <TEMPFILEGEN>;
	close TEMPFILEGEN;

	# Take off the first two elements of the array (unnecessary row and column data)
	if(scalar(@hilbert_data) > 2) {
		@hilbert_data = @hilbert_data[2..$#hilbert_data];
	}

	# Find unimodular simplicies
	
	# Create temp file for Sage commands
	# Using a temp file makes Sage run faster
	$SAGE_TEMPFILE = "temp.sage";
	system "rm $SAGE_TEMPFILE";
	system "touch $SAGE_TEMPFILE";
	if (! open SAGE_OUTPUT_FILE, ">", "$SAGE_TEMPFILE") {
		close INPUT;
		die "Trouble opening sage tempfile\n";		# error message
	}
		
	# Array of every 4x4 matricies
	@matrices;
	@hilbertLineNumbers;


	# Take all 4x4 submatricies of the .gen matrix 
	# Use Sage to find determinant
	$count = 0;
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {
		for ($ij = $ix+1; $ij < scalar(@hilbert_data); $ij++) {
			for ($iy = $ij+1; $iy < scalar(@hilbert_data); $iy++) {
				for ($iz = $iy+1; $iz < scalar(@hilbert_data); $iz++) {
					
					# Builds 4x4 matrix from Hilbert basis
					@subarray = (split(/\s+/,@hilbert_data[$ix]), split(/\s+/,@hilbert_data[$ij]), split(/\s+/,@hilbert_data[$iy]), split(/\s+/,@hilbert_data[$iz]));
					
					# Puts all submatricies in array
					@matrices[$count] = join(',', @subarray);
					push(@hilbertLineNumbers, "$ix,$ij,$iy,$iz");
					$count++;

					# Builds commad
					$command = sprintf("M = MatrixSpace(QQ,4,4); A = M([%s]); print det(A);\n", join(',', @subarray));

					# Puts commands into temp file
					print SAGE_OUTPUT_FILE $command;
				}
			}
		}
	}
	
	close SAGE_OUTPUT_FILE;

	$now = time;
	
	# Store determinants in temp file, line numbers corresponds to line numbers in @matricies array
	$DETERMINANTS_FILE = 'sage_determinants.txt';

	# Use Sage to find determinants
	$command = "/Applications/sage/sage $SAGE_TEMPFILE > $DETERMINANTS_FILE";
	system $command;
	$later = time;
	printf "Took %d seconds to run $count matrices through sage\n\n", ($later-$now), $count;
	
	
	# Capture determiant value
	# Read in determinants form temp file
	if (! open DETERMINANTS_FILE, $DETERMINANTS_FILE) {
		close INPUT;
		die "Trouble opening file $DETERMINANTS_FILE\n";		# error message
	}


	# Slurp the determinatns into an array
	@determinants = <DETERMINANTS_FILE>;
	
	close DETERMINANTS_FILE;
	
	# Find unimodular simplicies and store in @unimodular_array
	@unimodular_array;
	@unimodular_list;	
	$count = 0;
	for($ix = 0; $ix < scalar(@determinants); $ix++) {
		$det = int(@determinants[$ix]);

		# If det= = 1,-1 save simplex
		if ($det == -1 || $det == 1) {
			push(@unimodular_array, @matrices[$ix]);
			
			# Keep track of Hilbert basis line numbers
			push(@unimodular_list, @hilbertLineNumbers[$ix]);
		}
	}
	
	printf "Unimodular List is %d long\n", scalar(@unimodular_list);
	
	
	# Generate a generic point

	@random_array;
	
	# Generate random rational numbers between 0 and 10,000
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {		
		$r = rand(10_000);
		@random_array[$ix] = $r;
	}


	# Generate generic_pt
	@generic_pt;
	for ($ix = 0; $ix < 4; $ix++) {		
		$temp = 0;		
		for ($iy = 0; $iy < scalar(@hilbert_data); $iy++) {	
			$random = @random_array[$iy];
			@hilbert = split(/\s+/, @hilbert_data[$iy]);
			$temp += ($random * @hilbert[$ix]);
		}			
		@generic_pt[$ix] = $temp;
	}
	
	# printf "Generic point is %s\n", join(', ', @generic_pt);


	# Find simplicies in which the generic_pt lives	
	
	# Create temp file for Sage commands
	$GENERIC_TEMPFILE = "generic.sage";
	system "rm $GENERIC_TEMPFILE";
	system "touch $GENERIC_TEMPFILE";
	if (! open GENERIC_OUTPUT_FILE, ">", "$GENERIC_TEMPFILE") {
		close INPUT;
		die "Trouble opening generic point tempfile\n";		# error message
	}
	
	
	@unimodular_transpose;
	$string;
	@string;
	@transpose;
	@unimodular_transpose;
	# Find the tranpose of each 4x4 unimodular matrix
	for ($ix = 0; $ix < scalar(@unimodular_array); $ix++) {
		$count = 0;
		$string = @unimodular_array[$ix];
		@string = split(/,/, $string);	

		for ($iy = 0; $iy < 16; $iy += 4) {
			@transpose[$count] = @string[$iy];
			$count++;
		}
		for ($ij = 1; $ij < 16; $ij += 4) {
			@transpose[$count] = @string[$ij];
			$count++;
		}
		for ($ik = 2; $ik < 16; $ik += 4) {
			@transpose[$count] = @string[$ik];
			$count++;
		}
		for ($iz = 3; $iz < 16; $iz += 4) {
			@transpose[$count] = @string[$iz];
			$count++;
		}
				
		# Puts all submatricies in array
		@unimodular_transpose[$ix] = join(',',@transpose);		
	}
	
	# Take each unimodular simplex and ask Sage to solve A_i [x_1,x_2,x_3,x_4] = generic_pt
	for ($ix = 0; $ix < scalar(@unimodular_transpose); $ix++) {
		# Build Sage commands
		$command = sprintf "M44 = MatrixSpace(QQ,4,4); A = M44([%s]); V4 = VectorSpace(QQ,4); b = V4([%s]); print octave.solve_linear_system(A,b); \n", @unimodular_transpose[$ix], join(',', @generic_pt);
		print GENERIC_OUTPUT_FILE $command;
	}

	close GENERIC_OUTPUT_FILE;
	
	# Use Sage to find solution
	$SOLUTIONS_FILE = "generic.sage.out";
	system "/Applications/sage/sage $GENERIC_TEMPFILE > $SOLUTIONS_FILE";
	
	
	# Capture solutions
	# Read in solutions form temp file
	if (! open SOLUTIONS_FILE, $SOLUTIONS_FILE) {
		close INPUT;
		die "Trouble opening file $SOLUTIONS_FILE\n";		# error message
	}


	# Slurp the solutions into an array
	@solutions_array = <SOLUTIONS_FILE>;
	close SOLUTIONS_FILE;

	# If matrix of has a positive solution, then generic_pt lives inside simplex
	# First equation is sum x = 1 for those simplicies it lives inside
	
	@first_eq_array;
	@solution;
	
	for($ix = 0; $ix < scalar(@solutions_array); $ix++) {
		# Clean and split the solution (4 numbers)
		$string = @solutions_array[$ix];		
		chomp($string);
		@solution = split(/,/, substr($string, 1, length($string)-2));
		
		# iterate the solution array
		$all_positive = 1;
		for($ij = 0; $ij < scalar(@solution); $ij++) {			
			if(@solution[$ij] <= 0) {
				$all_positive = 0;
			}
		}
		
		push(@first_eq_array, $all_positive);
				
	}
	
	#	printf "Solutions array is %d elements long\n", scalar(@solutions_array);
	#	printf "Equations array is %d elements long\n", scalar(@first_eq_array);

	# Last entry in first equation is 1
	push(@first_eq_array, 1);

	# printf "First equation %s\n", join(', ', @first_eq_array);

	# Finds the interior facets of the simplicies
		

	# For each simpliex gererate facets
	# define new 4x4 matrix F = [ x_i line 2 line 3 line 4] 
	# Find all simplices that contain that facet


	@facets;
	# Find all possible facets
	for ($ix = 0; $ix < scalar(@hilbert_data); $ix++) {
		for ($ij = $ix+1; $ij < scalar(@hilbert_data); $ij++) {
			for ($iy = $ij+1; $iy < scalar(@hilbert_data); $iy++) {
				
				push(@facets, "$ix,$ij,$iy");
			}
		}
	}

	@latte_equations;

	# For each facet check if it is in a unimodular simplex
	for ($ix = 0; $ix < scalar(@facets); $ix++) {
		my @currentFacet = split(/,/, @facets[$ix]);
		
		my @facetEquation = ();
		
		# For each unimodular simplex check if it contains the facet
		for ($iy = 0; $iy < scalar(@unimodular_list); $iy++) {
			my @currentUnimodular = split(/,/, @unimodular_list[$iy]);
			
			# Checking if simplex contains facet
			# Compute the difference between the facet and the unimodular
			@difference = &difference(\@currentUnimodular, \@currentFacet);

			# If the facet is in the unimodular simplex then check it it is interior and build equation
			# The unimodular contains the difference if there is exactly one different element
			if(scalar(@difference) == 1) {
				# Create 3x4 array from original hilbert basis
				my @subHilbertMatrix;
				my $line1 = @hilbert_data[@currentFacet[0]];
				chomp($line1);
				my $line2 = @hilbert_data[@currentFacet[1]];
				chomp($line2);
				my $line3 = @hilbert_data[@currentFacet[2]];
				chomp($line3);				
				push(@subHilbertMatrix, split(/\s+/, $line1), split(/\s+/, $line2), split(/\s+/, $line3));
				
				# Find determinants of each 3x4 matrix
				
				# Builds 3x3 matrix from Sub-Hilbert basis matrix (3x4)
				@det1 = (@subHilbertMatrix[1], @subHilbertMatrix[2], @subHilbertMatrix[3],
						 @subHilbertMatrix[5], @subHilbertMatrix[6], @subHilbertMatrix[7],
						 @subHilbertMatrix[9], @subHilbertMatrix[10], @subHilbertMatrix[11]);
				
				@det2 = (@subHilbertMatrix[0], @subHilbertMatrix[2], @subHilbertMatrix[3],
						 @subHilbertMatrix[4], @subHilbertMatrix[6], @subHilbertMatrix[7],
						 @subHilbertMatrix[8], @subHilbertMatrix[10], @subHilbertMatrix[11]);
				
				@det3 = (@subHilbertMatrix[0], @subHilbertMatrix[1], @subHilbertMatrix[3],
						 @subHilbertMatrix[4], @subHilbertMatrix[5], @subHilbertMatrix[7],
						 @subHilbertMatrix[8], @subHilbertMatrix[9], @subHilbertMatrix[11]);
				
				@det4 = (@subHilbertMatrix[0], @subHilbertMatrix[1], @subHilbertMatrix[2],
						 @subHilbertMatrix[4], @subHilbertMatrix[5], @subHilbertMatrix[6],
						 @subHilbertMatrix[8], @subHilbertMatrix[9], @subHilbertMatrix[10]);

			# Builds commad
				$command = join('',sprintf("M = MatrixSpace(QQ,3,3); A = M([%s]); print det(A);", join(',', @det1)),
						   sprintf("M = MatrixSpace(QQ,3,3); A = M([%s]); print det(A);", join(',', @det2)),
						   sprintf("M = MatrixSpace(QQ,3,3); A = M([%s]); print det(A);", join(',', @det3)),
						   sprintf("M = MatrixSpace(QQ,3,3); A = M([%s]); print det(A);", join(',', @det4)));
				
				# Use Sage to find determinants
				$command = "/Applications/sage/sage -c \"$command\"";
				
				chomp(my @det_vector = `$command`);

				# Test if the facet is interior and what side of the facet the simplex lives on				
				@current_hilbert = split(' ', @hilbert_data[@difference[0]]);
				
				$dot_product = (@det_vector[0] * @current_hilbert[0]) - (@det_vector[1] * @current_hilbert[1]) + (@det_vector[2] * @current_hilbert[2]) - (@det_vector[3] * @current_hilbert[3]);
				
				# Simplex lives on positive side
				if( $dot_product > 0) {
					push(@facetEquation, 1);
				}
				# Simplex lives on negative side
				if( $dot_product < 0) {	
					push(@facetEquation, -1);
				}
				
			} else {		# Facet is not contained in simplex
				push(@facetEquation, 0);
			}
			
		}	
		
		# Test if facet is interior
		# Iterate the eqation array
		$has_positive = 0;
		$has_negative = 0;
		for($ij = 0; $ij < scalar(@facetEquation); $ij++) {
			if(@facetEquation[$ij] < 0) {
				$has_negative = 1;
			}
			
			if(@facetEquation[$ij] > 0) {
				$has_positive = 1;
			}			
		}
		
		# Facet is interior if coefficient are both postive and negative
		# If coefficient are all postive or all negative then it is not interior
		if($has_positive && $has_negative) {			
			# Put 0 at end of equation
			push(@facetEquation, 0);
			
			# Puts all submatricies in array
			push(@latte_equations, join(' ', @facetEquation));	
		}
		
		print "Facet (@currentFacet) equation is @facetEquation (" . @facetEquation . ") long\n";
	}


	# Latte temp file
	# first line: number of equations
	# second line: number of variables
	# equations
	# last line: "linearity i 1, 2, 3, ..."
		
	# Create temp file for Latte equations
	$LATTE_TEMPFILE = "temp.latte";
	system "rm $LATTE_TEMPFILE";
	system "touch $LATTE_TEMPFILE";
	if (! open LATTE_INPUT_FILE, ">", "$LATTE_TEMPFILE") {
		die "Trouble opening latte tempfile\n";		# error message
	}
	
	$number_of_equations = scalar(@latte_equations) + 1;
	@linearity;
	push(@linearity, (1..$number_of_equations));
	
	printf LATTE_INPUT_FILE "%d\n%d\n%s\n", $number_of_equations, scalar(@unimodular_array), join(' ', @first_eq_array);
	for $i (@latte_equations) {
		printf LATTE_INPUT_FILE "%s\n", $i;
	}
	printf LATTE_INPUT_FILE "linearity %d %s\n", $number_of_equations, join(' ',@linearity);
	
	# Use Latte for yes or no answer
	# Is there a lattice point?  ./count int temp.latte

	system "/Applications/latte/count int temp.latte";
	exit;
	# if no then keep hilbert_basis tempfile
}

close INPUT;

sub difference {
	my($array1, $array2) = @_;
	my @diff;
	for $i (@$array1) {
		push(@diff, $i) if ! grep {$i == $_} @$array2;
	}
	return @diff;
}






